(function (nativeDefineProperty) {
	var call = Function.call;
	var prototypeOfObject = Object.prototype;
	var owns = call.bind(prototypeOfObject.hasOwnProperty);

	// If JS engine supports accessors creating shortcuts.
	var defineGetter;
	var defineSetter;
	var lookupGetter;
	var lookupSetter;
	var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
	if (supportsAccessors) {
			defineGetter = call.bind(prototypeOfObject.__defineGetter__);
			defineSetter = call.bind(prototypeOfObject.__defineSetter__);
			lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
			lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
	}

	var isPrimitive = function (o) {
			return o == null || (typeof o !== 'object' && typeof o !== 'function');
	};
	// ES5 15.2.3.6
	// http://es5.github.com/#x15.2.3.6

	// Patch for WebKit and IE8 standard mode
	// Designed by hax <hax.github.com>
	// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
	// IE8 Reference:
	//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
	//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
	// WebKit Bugs:
	//     https://bugs.webkit.org/show_bug.cgi?id=36423

	var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
		try {
				nativeDefineProperty(object, 'sentinel', {});
				return 'sentinel' in object;
		} catch (exception) {
				return false;
		}
	};

	// check whether defineProperty works if it's given. Otherwise,
	// shim partially.
	if (nativeDefineProperty) {
			var definePropertyWorksOnObject = doesDefinePropertyWork({});
			var definePropertyWorksOnDom = typeof document === 'undefined'
					|| doesDefinePropertyWork(document.createElement('div'));
			if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
					var definePropertyFallback = nativeDefineProperty;
			}
	}
	var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
	var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
	var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

	Object.defineProperty = function defineProperty(object, property, descriptor) {
			if (isPrimitive(object)) {
					throw new TypeError(ERR_NON_OBJECT_TARGET + object);
			}
			if (isPrimitive(descriptor)) {
					throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
			}
			// make a valiant attempt to use the real defineProperty
			// for I8's DOM elements.
			if (definePropertyFallback) {
					try {
							return definePropertyFallback.call(Object, object, property, descriptor);
					} catch (exception) {
							// try the shim if the real one doesn't work
					}
			}

			// If it's a data property.
			if ('value' in descriptor) {
					// fail silently if 'writable', 'enumerable', or 'configurable'
					// are requested but not supported
					/*
					// alternate approach:
					if ( // can't implement these features; allow false but not true
							('writable' in descriptor && !descriptor.writable) ||
							('enumerable' in descriptor && !descriptor.enumerable) ||
							('configurable' in descriptor && !descriptor.configurable)
					))
							throw new RangeError(
									'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
							);
					*/

					if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
							// As accessors are supported only on engines implementing
							// `__proto__` we can safely override `__proto__` while defining
							// a property to make sure that we don't hit an inherited
							// accessor.
							/* eslint-disable no-proto */
							var prototype = object.__proto__;
							object.__proto__ = prototypeOfObject;
							// Deleting a property anyway since getter / setter may be
							// defined on object itself.
							delete object[property];
							object[property] = descriptor.value;
							// Setting original `__proto__` back now.
							object.__proto__ = prototype;
							/* eslint-enable no-proto */
					} else {
							object[property] = descriptor.value;
					}
			} else {
					var hasGetter = 'get' in descriptor;
					var hasSetter = 'set' in descriptor;
					if (!supportsAccessors && (hasGetter || hasSetter)) {
							throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
					}
					// If we got that far then getters and setters can be defined !!
					if (hasGetter) {
							defineGetter(object, property, descriptor.get);
					}
					if (hasSetter) {
							defineSetter(object, property, descriptor.set);
					}
			}
			return object;
	};
}(Object.defineProperty));
